
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Read Me</title><meta name="generator" content="MATLAB 8.6"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2018-11-28"><meta name="DC.source" content="SNRandCNRfieldDependenceJMRI.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Read Me</h1><!--introduction--><p>cd to the directory where the function SNRandCNRfieldDependenceJMRI.m is located you can either run the whole code or simply use the html file to navigate through the results</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">initializing path and variables</a></li><li><a href="#2">initializing relaxation times field dependence</a></li><li><a href="#3">relaxation parameters - plotting relaxation parameters as a function of field</a></li><li><a href="#4">Functions</a></li><li><a href="#5">T1-w imaging</a></li><li><a href="#6">PD-w imaging</a></li><li><a href="#7">T2*-w imaging contrast</a></li><li><a href="#9">2D GRE signal considering the number of interleaved slices per TR</a></li><li><a href="#10">End of simulations</a></li></ul></div><h2>initializing path and variables<a name="1"></a></h2><pre class="codeinput">close <span class="string">all</span>
clear <span class="string">all</span>

CurrDirectory = pwd ;
addpath(genpath(CurrDirectory)) ;

gamma = 42.577e6 ;          <span class="comment">% gyromagnetic constant in Hz</span>
SNR_PowerLaw = 1.5 ;        <span class="comment">% at High Fields this has been measured at 1.68, at lower fields it is expected to tend towards 1 because noise in the sample</span>
B0 = [0.1:0.1:7] ;          <span class="comment">% range of fields of simulations</span>

<span class="comment">%(time needed to crush magnetization, apply slice selective and phase encoding gradients)</span>
DeadTime = 3e-3 ;           <span class="comment">% assumption of dead time within a GRE</span>

PDT1approach = <span class="string">'ShortEnoughTE'</span> ; <span class="comment">% options are 'ShortEnoughTE' or 'minTR'</span>
minTR = 7e-3 ;              <span class="comment">% minimum repetition time achievable (used in PD and T1w in case of minTR)</span>
TEfractionOfT2 = 1 / 8 ;    <span class="comment">% fraction of shorter T2 at which we assume that no T2* contrast exists (used for PD and T1w)</span>

PDflip_Ernstfract = 0.25 ;  <span class="comment">% fraction of the Ernst flip angle used for PD</span>

TE_SpinEcho = 70e-3;        <span class="comment">% used on the 2D example</span>

PlotIntermediate = 0 ;
</pre><h2>initializing relaxation times field dependence<a name="2"></a></h2><p>Longitudinal and transverse relaxation rates using the models presented in: - Rooney et al MRM 2007; - Pohmann et al MRM 2016;</p><pre class="codeinput"><span class="comment">% R1 as a function of magnetic field according to</span>
<span class="comment">% Rooney et al, MRM, 2007</span>
<span class="comment">% and using a model suggested by Bottemley et al, Med Phys, 1984</span>
T1_WM = 0.00071 * (gamma*B0).^0.382;
T1_GM = 0.00116 * (gamma*B0).^0.376;
T1_BL = 0.00335 * (gamma*B0).^0.340;
T1_CSF =1/0.231 * ones(size(B0));

<span class="comment">% using Pohmann et al, MRM, 2016</span>
T2s_GM = 0.090 * exp(-0.142 *B0);
T2s_WM = 0.064 * exp(-0.132 *B0);
T2s_CSF = 0.1*ones(size(B0)); <span class="comment">% made up.. but not too relevant</span>
SNR_B0 = B0.^SNR_PowerLaw ;
</pre><h2>relaxation parameters - plotting relaxation parameters as a function of field<a name="3"></a></h2><pre class="codeinput">figure(<span class="string">'name'</span>,<span class="string">'Relaxation Rates '</span>,<span class="string">'numbertitle'</span>,<span class="string">'off'</span>)
set(gcf,<span class="string">'Position'</span>,[ 11   627   917   369],<span class="string">'Color'</span>,[1 1 1])
subplot(121)
hold <span class="string">off</span>
plot(B0,1./T1_GM,<span class="string">'-'</span>,<span class="string">'Color'</span>,[1 1 1]*0.0,<span class="string">'Linewidth'</span>,2)
hold <span class="string">on</span>
plot(B0,1./T1_WM,<span class="string">'-'</span>,<span class="string">'Color'</span>,[1 1 1]*0.35,<span class="string">'Linewidth'</span>,2)
plot(B0,1./T1_CSF,<span class="string">'-.'</span>,<span class="string">'Color'</span>,[1 1 1]*0.8,<span class="string">'Linewidth'</span>,2)
legend(<span class="string">'GM '</span>,<span class="string">'WM '</span>, <span class="string">'CSF'</span>);
title ([<span class="string">'R_1 as a function of B_0'</span>])
ylabel([<span class="string">'R_1 (s^{-1})'</span>])
xlabel([<span class="string">'B_0 (T)'</span>])
axis <span class="string">tight</span>

subplot(122)
hold <span class="string">off</span>
plot(B0,1./T2s_GM,<span class="string">'-'</span>,<span class="string">'Color'</span>,[1 1 1]*0.0,<span class="string">'Linewidth'</span>,2)
hold <span class="string">on</span>
plot(B0,1./T2s_WM,<span class="string">'-'</span>,<span class="string">'Color'</span>,[1 1 1]*0.35,<span class="string">'Linewidth'</span>,2)
legend(<span class="string">'GM '</span>,<span class="string">'WM '</span>)
title ([<span class="string">'R_2^* as a function of B_0'</span>])
ylabel([<span class="string">'R_2^* (s^{-1})'</span>])
xlabel([<span class="string">'B_0 (T)'</span>])
axis <span class="string">tight</span>
fontScale(1.1)


figure(<span class="string">'name'</span>,<span class="string">'Relaxation times '</span>,<span class="string">'numbertitle'</span>,<span class="string">'off'</span>)
set(gcf,<span class="string">'Position'</span>,[ 11   627   917   369],<span class="string">'Color'</span>,[1 1 1])
subplot(121)
hold <span class="string">off</span>
plot(B0,T1_GM,<span class="string">'-'</span>,<span class="string">'Color'</span>,[1 1 1]*0.0,<span class="string">'Linewidth'</span>,2)
hold <span class="string">on</span>
plot(B0,T1_WM,<span class="string">'-'</span>,<span class="string">'Color'</span>,[1 1 1]*0.4,<span class="string">'Linewidth'</span>,2)
plot(B0,T1_CSF,<span class="string">'-.'</span>,<span class="string">'Color'</span>,[1 1 1]*0.8,<span class="string">'Linewidth'</span>,2)
legend(<span class="string">'GM '</span>,<span class="string">'WM '</span>, <span class="string">'CSF'</span>,<span class="string">'Location'</span>,<span class="string">'East'</span>);
axis <span class="string">tight</span>
axis([0 max(B0) 0 max(T1_CSF)*1.1])
title ([<span class="string">'T_1 as a function of B0'</span>])
ylabel([<span class="string">'T_1 (s)'</span>])
xlabel([<span class="string">'B_0 (T)'</span>])

subplot(122)
hold <span class="string">off</span>
plot(B0,T2s_GM,<span class="string">'-'</span>,<span class="string">'Color'</span>,[1 1 1]*0.0,<span class="string">'Linewidth'</span>,2)
hold <span class="string">on</span>
plot(B0,T2s_WM,<span class="string">'-'</span>,<span class="string">'Color'</span>,[1 1 1]*0.4,<span class="string">'Linewidth'</span>,2)
axis <span class="string">tight</span>
axis([0 max(B0) 0 max(T2s_GM)*1.1])

legend(<span class="string">'GM '</span>,<span class="string">'WM '</span>)
title ([<span class="string">'T_2^* as a function of B0'</span>])
ylabel([<span class="string">'T_2^* (s)'</span>])
xlabel([<span class="string">'B_0 (T)'</span>])
fontScale(1.1)
<span class="comment">% savefig('RelaxationTimes')</span>
</pre><img vspace="5" hspace="5" src="SNRandCNRfieldDependenceJMRI_01.png" alt=""> <img vspace="5" hspace="5" src="SNRandCNRfieldDependenceJMRI_02.png" alt=""> <h2>Functions<a name="4"></a></h2><p>Ernst Angle and GRE signal calculation</p><pre class="codeinput"><span class="comment">% Ernst Angle Calculation in degrees</span>
Ernstangle_d = @(TRep,T1) acosd( exp(-TRep./T1) );

<span class="comment">% GRESignal calculation</span>
GRESignal = @(FlipAngle,TRep,TE,T1,T2) sind(FlipAngle).*exp(-TE/T2).*(1-exp(-TRep./T1))./(1-(exp(-TRep./T1)).*cosd(FlipAngle));
</pre><h2>T1-w imaging<a name="5"></a></h2><p>Sequence optimized (flip angle and TR, while TE= T2s_WM * TEfractionOfT2) at each B0 to yield maximum contrast between grey and white matter</p><pre class="codeinput"><span class="keyword">if</span> strcmp(PDT1approach,<span class="string">'minTR'</span>)
    <span class="comment">% At Fixed TR</span>
    TR = minTR * ones(size(B0));
    TE = TR / 2;
<span class="keyword">elseif</span> strcmp(PDT1approach,<span class="string">'ShortEnoughTE'</span>)
    <span class="comment">% Using a "short" TE in respect to T2 of WM</span>
    TE = T2s_WM * TEfractionOfT2;
    TR = 2 * TE;
<span class="keyword">else</span>
    error(<span class="string">'Unknow PD and T1 approach, it has to be either ''ShortEnoughTE'' or ''minTR'' '</span>)
<span class="keyword">end</span>;

<span class="comment">% calculation of signal</span>
BW = 1 ./ (2 * TE - DeadTime);

OptimumTheta=zeros([1,length(B0)]);
<span class="keyword">for</span> k=1:length(B0)
    [OptimumTheta(k)]=simContrastvFlip([T1_WM(k) T1_GM(k)],TR(k),0);
<span class="keyword">end</span>;
GREs_GM = GRESignal(OptimumTheta,TR,TE,T1_GM,T2s_GM);
GREs_WM = GRESignal(OptimumTheta,TR,TE,T1_WM,T2s_WM);
GREs_CSF = GRESignal(OptimumTheta,TR,TE,T1_CSF,T2s_CSF);

figure(<span class="string">'name'</span>,<span class="string">'T1w imaging '</span>,<span class="string">'numbertitle'</span>,<span class="string">'off'</span>)
set(gcf,<span class="string">'Position'</span>,[ 936   165   917   369],<span class="string">'Color'</span>,[1 1 1])
subplot(121)
hold <span class="string">off</span>
plot(B0,GREs_GM,<span class="string">'-'</span>,<span class="string">'Color'</span>,[1 1 1]*0.0,<span class="string">'Linewidth'</span>,2)
hold <span class="string">on</span>
plot(B0,GREs_WM,<span class="string">'-'</span>,<span class="string">'Color'</span>,[1 1 1]*0.35,<span class="string">'Linewidth'</span>,2)
plot(B0,GREs_CSF,<span class="string">'-.'</span>,<span class="string">'Color'</span>,[1 1 1]*0.8,<span class="string">'Linewidth'</span>,2)
plot(B0,GREs_WM-GREs_GM,<span class="string">'-'</span>,<span class="string">'Color'</span>,[1 1 1]*0.6,<span class="string">'Linewidth'</span>,2)
legend(<span class="string">'GM '</span>,<span class="string">'WM '</span>,<span class="string">'CSF'</span>,<span class="string">'GM vs WM contrast'</span>)
<span class="comment">% legend('GM ','WM ','GM vs WM contrast')</span>
title ([<span class="string">'T_1w Signal as a function of B_0'</span>])
ylabel([<span class="string">'Signal '</span>])
xlabel([<span class="string">'B_0 (T)'</span>])
axis <span class="string">tight</span>

subplot(122)
hold <span class="string">off</span>

plot(B0,SNR_B0 .* 1./sqrt(TR) .*1./sqrt(BW) .*GREs_GM,<span class="string">'-'</span>,<span class="string">'Color'</span>,[1 1 1]*0.0,<span class="string">'Linewidth'</span>,2)
hold <span class="string">on</span>
plot(B0,SNR_B0 .* 1./sqrt(TR) .*1./sqrt(BW) .*GREs_WM,<span class="string">'-'</span>,<span class="string">'Color'</span>,[1 1 1]*0.35,<span class="string">'Linewidth'</span>,2)
plot(B0,SNR_B0 .* 1./sqrt(TR) .*1./sqrt(BW) .*GREs_CSF,<span class="string">'-'</span>,<span class="string">'Color'</span>,[1 1 1]*0.8,<span class="string">'Linewidth'</span>,2)
plot(B0,SNR_B0 .* 1./sqrt(TR) .*1./sqrt(BW) .*(GREs_WM-GREs_GM),<span class="string">'-'</span>,<span class="string">'Color'</span>,[1 1 1]*0.6,<span class="string">'Linewidth'</span>,2)
<span class="comment">% legend('GM ','WM ','GM vs WM contrast')</span>
title ([<span class="string">'T_1w SNR accounting for TR and BW'</span>])
ylabel([<span class="string">'SNR (au)'</span>])
xlabel([<span class="string">'B_0 (T)'</span>])
axis <span class="string">tight</span>
y1 = SNR_B0 .* 1./sqrt(TR) .*1./sqrt(BW) .*(GREs_WM );
y = SNR_B0 .* 1./sqrt(TR) .*1./sqrt(BW) .*(GREs_WM -GREs_GM);


<span class="comment">% fitting the model using a log transform re-weighted by the amplitude for</span>
<span class="comment">% a more balanced weigthting</span>
beta = PowerLawFit(y,B0);

plot(B0,beta(1)*B0.^(beta(2)),<span class="string">'-.'</span>,<span class="string">'Color'</span>,[1 1 1]*0.6,<span class="string">'Linewidth'</span>,2)
legend(<span class="string">'GM '</span>,<span class="string">'WM '</span>,<span class="string">'CSF'</span>,<span class="string">'GM vs WM contrast'</span>,<span class="string">'GM vs WM contrast fit'</span>,<span class="string">'Location'</span>,<span class="string">'East'</span>)


text(min(B0)+(max(B0)-min(B0))*0.05 ,max(y1)*0.9,[<span class="string">'Power Law of T_1w CNR = B_0 ^{'</span>,num2str(round(beta(2)*100)/100),<span class="string">'}'</span>])
text(min(B0)+(max(B0)-min(B0))*0.05 ,max(y1)*0.8,[<span class="string">'Power Law of SNR = B_0 ^{'</span>,num2str(round(SNR_PowerLaw*10)/10),<span class="string">'}'</span>])
fontScale(1.1)


<span class="comment">%  savefig('T1wCNR_VariableTR')</span>
figure(<span class="string">'name'</span>,<span class="string">'T1w Ernst Angle '</span>,<span class="string">'numbertitle'</span>,<span class="string">'off'</span>)
set(gcf,<span class="string">'Position'</span>,[ 1367  599  426 344],<span class="string">'Color'</span>,[1 1 1])
hold <span class="string">off</span>
plot(B0,TR*1000,<span class="string">'-'</span>,<span class="string">'Color'</span>,[1 1 1]*0.0,<span class="string">'Linewidth'</span>,2)
hold <span class="string">on</span>
plot(B0,OptimumTheta,<span class="string">'-'</span>,<span class="string">'Color'</span>,[1 1 1]*0.5,<span class="string">'Linewidth'</span>,2)
legend(<span class="string">'TR (ms)'</span>,<span class="string">'Flip Angle (degrees)'</span>)
legend(<span class="string">'TR (ms)'</span>,<span class="string">'Flip Angle (degrees)'</span>,<span class="string">'Location'</span>,<span class="string">'Best'</span>)
xlabel([<span class="string">'B_0 (T)'</span>])
ylabel([<span class="string">'Flip Angle (degrees) ; TR (ms)'</span>])
title([<span class="string">'sequence Paraemters as a function of B_0'</span>])
fontScale(1.1)

<span class="comment">% savefig('T1w_VariableTR_parameters')</span>
</pre><img vspace="5" hspace="5" src="SNRandCNRfieldDependenceJMRI_03.png" alt=""> <img vspace="5" hspace="5" src="SNRandCNRfieldDependenceJMRI_04.png" alt=""> <h2>PD-w imaging<a name="6"></a></h2><p>Sequence optimized (flip angle = PDflip_Ernstfract  * ErnstAngle , while TE= T2s_WM * TEfractionOfT2) at each B0 to yield a proton density type of contrast</p><pre class="codeinput"><span class="keyword">if</span> strcmp(PDT1approach,<span class="string">'minTR'</span>)
    <span class="comment">%At Fixed TR</span>
    TR = minTR * ones(size(B0));
    TE = TR / 2;
<span class="keyword">elseif</span> strcmp(PDT1approach,<span class="string">'ShortEnoughTE'</span>)
    TE = T2s_WM * TEfractionOfT2;
    TR = 2 * TE;
<span class="keyword">else</span>
    error(<span class="string">'Unknow PD and T1 approach, it has to be either ''ShortEnoughTE'' or ''minTR'' '</span>)
<span class="keyword">end</span>;

<span class="comment">%calculation of signal</span>
BW = 1 ./ (2 * TE - DeadTime);
theta = PDflip_Ernstfract  * Ernstangle_d(TR,T1_GM);
GREs_GM = GRESignal(theta,TR,TE,T1_GM,T2s_GM);
GREs_WM = GRESignal(theta,TR,TE,T1_WM,T2s_WM);
GREs_CSF = GRESignal(theta,TR,TE,T1_CSF,T2s_CSF);

figure(<span class="string">'name'</span>,<span class="string">'PD imaging '</span>,<span class="string">'numbertitle'</span>,<span class="string">'off'</span>)

set(gcf,<span class="string">'Position'</span>,[ 938   627   917   369],<span class="string">'Color'</span>,[1 1 1])
subplot(121)
hold <span class="string">off</span>
plot(B0,GREs_GM,<span class="string">'-'</span>,<span class="string">'Color'</span>,[1 1 1]*0.0,<span class="string">'Linewidth'</span>,2)
hold <span class="string">on</span>
plot(B0,GREs_WM,<span class="string">'-'</span>,<span class="string">'Color'</span>,[1 1 1]*0.35,<span class="string">'Linewidth'</span>,2)
plot(B0,GREs_CSF,<span class="string">'-'</span>,<span class="string">'Color'</span>,[1 1 1]*0.8,<span class="string">'Linewidth'</span>,2)
legend(<span class="string">'GM '</span>,<span class="string">'WM '</span>,<span class="string">'CSF'</span>)
legend(<span class="string">'GM '</span>,<span class="string">'WM '</span>)
title ([<span class="string">'PD Signal as a function of B0'</span>])
ylabel([<span class="string">'Signal '</span>])
xlabel([<span class="string">'B_0 (T)'</span>])
axis <span class="string">tight</span>

subplot(122)
hold <span class="string">off</span>

plot(B0,SNR_B0 .* 1./sqrt(TR) .*1./sqrt(BW) .*GREs_GM,<span class="string">'-'</span>,<span class="string">'Color'</span>,[1 1 1]*0.0,<span class="string">'Linewidth'</span>,2)
hold <span class="string">on</span>
plot(B0,SNR_B0 .* 1./sqrt(TR) .*1./sqrt(BW) .*GREs_WM,<span class="string">'-'</span>,<span class="string">'Color'</span>,[1 1 1]*0.35,<span class="string">'Linewidth'</span>,2)
plot(B0,SNR_B0 .* 1./sqrt(TR) .*1./sqrt(BW) .*GREs_CSF,<span class="string">'-'</span>,<span class="string">'Color'</span>,[1 1 1]*0.8,<span class="string">'Linewidth'</span>,2)
title ([<span class="string">'PD SNR accounting for TR and BW'</span>])
ylabel([<span class="string">'SNR (au)'</span>])
xlabel([<span class="string">'B_0 (T)'</span>])
axis <span class="string">tight</span>
y = SNR_B0 .* 1./sqrt(TR) .*1./sqrt(BW) .*GREs_WM;

<span class="comment">% fitting the model</span>
beta = PowerLawFit(y,B0);

plot(B0,beta(1)*B0.^(beta(2)),<span class="string">'-.'</span>,<span class="string">'Color'</span>,[1 1 1]*0.6,<span class="string">'Linewidth'</span>,2)
text(min(B0)+(max(B0)-min(B0))*0.05 ,max(y)*0.9,[<span class="string">'Power Law of PD SNR = B_0 ^{'</span>,num2str(round(beta(2)*100)/100),<span class="string">'}'</span>])

text(min(B0)+(max(B0)-min(B0))*0.05 ,max(y)*0.8,[<span class="string">'Power Law of SNR = B_0 ^{'</span>,num2str(round(SNR_PowerLaw*10)/10),<span class="string">'}'</span>])
legend(<span class="string">'GM '</span>,<span class="string">'WM '</span>,<span class="string">'CSF '</span>,<span class="string">'GM fit'</span>,<span class="string">'Location'</span>,<span class="string">'East'</span>)
fontScale(1.1)
<span class="comment">% savefig('PDCNR_VariableTR')</span>
</pre><img vspace="5" hspace="5" src="SNRandCNRfieldDependenceJMRI_05.png" alt=""> <h2>T2*-w imaging contrast<a name="7"></a></h2><p>Sequence optimized to have the TE that gives the optimum GM WM contrast at given field Remainging parameters were optimizer for SNR</p><pre class="codeinput"><span class="keyword">for</span> k=1:length(B0)
    [TE(k)]=simContrastvTE([T2s_WM(k) T2s_GM(k)]*1000,0)/1000;
<span class="keyword">end</span>;
TR = 2 * TE;
OptimumTheta = Ernstangle_d(TR,T1_GM);
<span class="comment">%calculation of signal</span>
BW = 1 ./ (2 * TE - DeadTime);
GREs_GM = GRESignal(OptimumTheta,TR,TE,T1_GM,T2s_GM);
GREs_WM = GRESignal(OptimumTheta,TR,TE,T1_WM,T2s_WM);


figure(<span class="string">'name'</span>,<span class="string">'T2*w '</span>,<span class="string">'numbertitle'</span>,<span class="string">'off'</span>)
set(gcf,<span class="string">'Position'</span>,[8   167   917   369],<span class="string">'Color'</span>,[1 1 1])
subplot(121)
hold <span class="string">off</span>
plot(B0,GREs_GM,<span class="string">'-'</span>,<span class="string">'Color'</span>,[1 1 1]*0.0,<span class="string">'Linewidth'</span>,2)
hold <span class="string">on</span>
plot(B0,GREs_WM,<span class="string">'-'</span>,<span class="string">'Color'</span>,[1 1 1]*0.35,<span class="string">'Linewidth'</span>,2)
plot(B0,GREs_WM-GREs_GM,<span class="string">'-'</span>,<span class="string">'Color'</span>,[1 1 1]*0.6,<span class="string">'Linewidth'</span>,2)
legend(<span class="string">'GM '</span>,<span class="string">'WM '</span>,<span class="string">'GM vs WM contrast'</span>)
title ([<span class="string">'T_2*w Signal as a function of B_0'</span>])
ylabel([<span class="string">'Signal '</span>])
xlabel([<span class="string">'B_0 (T)'</span>])
axis <span class="string">tight</span>

subplot(122)
hold <span class="string">off</span>

plot(B0,SNR_B0 .* 1./sqrt(TR) .*1./sqrt(BW) .*GREs_GM,<span class="string">'-'</span>,<span class="string">'Color'</span>,[1 1 1]*0.0,<span class="string">'Linewidth'</span>,2)
hold <span class="string">on</span>
plot(B0,SNR_B0 .* 1./sqrt(TR) .*1./sqrt(BW) .*GREs_WM,<span class="string">'-'</span>,<span class="string">'Color'</span>,[1 1 1]*0.35,<span class="string">'Linewidth'</span>,2)
plot(B0,SNR_B0 .* 1./sqrt(TR) .*1./sqrt(BW) .*(GREs_GM-GREs_WM),<span class="string">'-'</span>,<span class="string">'Color'</span>,[1 1 1]*0.6,<span class="string">'Linewidth'</span>,2)
<span class="comment">%</span>
title ([<span class="string">'T2*w SNR accounting for TR and BW'</span>])
ylabel([<span class="string">'SNR (au)'</span>])
xlabel([<span class="string">'B_0 (T)'</span>])
axis <span class="string">tight</span>
y1 = SNR_B0 .* 1./sqrt(TR) .*1./sqrt(BW) .*(GREs_GM );
y = SNR_B0 .* 1./sqrt(TR) .*1./sqrt(BW) .*(GREs_GM -GREs_WM);
x0=[0.1 1];

<span class="comment">% fitting the model</span>
beta = PowerLawFit(y,B0);

plot(B0,beta(1)*B0.^(beta(2)),<span class="string">'-.'</span>,<span class="string">'Color'</span>,[1 1 1]*0.6,<span class="string">'Linewidth'</span>,2)
legend(<span class="string">'GM '</span>,<span class="string">'WM '</span>,<span class="string">'GM vs WM contrast'</span>,<span class="string">'GM vs WM contrast fit'</span>,<span class="string">'Location'</span>,<span class="string">'East'</span>)

text(min(B0)+(max(B0)-min(B0))*0.05 ,max(y1)*0.9,[<span class="string">'Power Law of T2*w CNR = B_0 ^{'</span>,num2str(round(beta(2)*100)/100),<span class="string">'}'</span>])
text(min(B0)+(max(B0)-min(B0))*0.05 ,max(y1)*0.8,[<span class="string">'Power Law of SNR = B_0 ^{'</span>,num2str(round(SNR_PowerLaw*10)/10),<span class="string">'}'</span>])
fontScale(1.1)

<span class="comment">% savefig('T2swCNR_VariableTR ')</span>
</pre><img vspace="5" hspace="5" src="SNRandCNRfieldDependenceJMRI_06.png" alt=""> <h2>2D GRE signal considering the number of interleaved slices per TR<a name="9"></a></h2><p>T1 and T2*-w were obtained using the same consideration as in the previous sections; T2w in diffusion like experiments was also simulated:       TE assumed to be constant across fields</p><pre class="codeinput">Nslices =1:64;
<span class="keyword">if</span> PlotIntermediate

    fnumbT2 = figure(<span class="string">'name'</span>,<span class="string">'2D T2* Ernst Angle '</span>,<span class="string">'numbertitle'</span>,<span class="string">'off'</span>,<span class="string">'Color'</span>,[1 1 1])

    fnumbT1 = figure(<span class="string">'name'</span>,<span class="string">'2D T1w  '</span>,<span class="string">'numbertitle'</span>,<span class="string">'off'</span>,<span class="string">'Color'</span>,[1 1 1])

    fnumbSE = figure(<span class="string">'name'</span>,<span class="string">'2D Spin Echo '</span>,<span class="string">'numbertitle'</span>,<span class="string">'off'</span>,<span class="string">'Color'</span>,[1 1 1])
<span class="keyword">end</span>;
<span class="keyword">for</span> Ns=Nslices;
    <span class="comment">% T2* contrast</span>

    <span class="keyword">for</span> k=1:length(B0)
        [TE(k)]=simContrastvTE([T2s_WM(k) T2s_GM(k)]*1000,0)/1000;
    <span class="keyword">end</span>;
    <span class="comment">%calculation of signal</span>
    BW = 1 ./ (2 * TE - DeadTime);
    TR = 2 * TE * Ns;
    OptimumTheta = Ernstangle_d(TR,T1_GM);

    GREs_GM = GRESignal(OptimumTheta,TR,TE,T1_GM,T2s_GM);
    GREs_WM = GRESignal(OptimumTheta,TR,TE,T1_WM,T2s_WM);

    y1 = SNR_B0 .* 1./sqrt(TR) .*1./sqrt(BW) .*(GREs_GM );
    y = SNR_B0 .* 1./sqrt(TR) .*1./sqrt(BW) .*(GREs_GM -GREs_WM);
    <span class="comment">% fitting the model</span>
    beta = PowerLawFit(y,B0);
    <span class="comment">% plot(B0,beta(1)*B0.^(beta(2)),'-.','Color',[1 1 1]*0.6,'Linewidth',2)</span>
    powerlawT2star(Ns)=beta(2);
    propT2star(Ns)=beta(1);


    <span class="keyword">if</span> PlotIntermediate
        figure(fnumbT2)
        <span class="keyword">if</span> Ns==1, hold <span class="string">off</span>, <span class="keyword">end</span>;
        subplot(121)
        plot(B0,y,<span class="string">'Color'</span>,[1 1 1]*(Ns-min(Nslices))/max(Nslices))
        ylabel([<span class="string">' SNR (au)'</span>])
        xlabel([<span class="string">'B_0 (T)'</span>])
        hold <span class="string">on</span>
        subplot(122)
        plot(B0,beta(1)*B0.^(beta(2)),<span class="string">'-.'</span>,<span class="string">'Color'</span>,[1 1 1]*(Ns-min(Nslices))/max(Nslices),<span class="string">'Linewidth'</span>,2)
        hold <span class="string">on</span>
        ylabel([<span class="string">'fitted SNR (au)'</span>])
        xlabel([<span class="string">'B_0 (T)'</span>])
    <span class="keyword">end</span>;

    <span class="comment">% T1 contrast</span>
    TE = T2s_WM * TEfractionOfT2;
    TR = 2 * TE * Ns;

    <span class="comment">%calculation of signal</span>
    BW = 1 ./ (2 * TE - DeadTime);


    <span class="keyword">for</span> k=1:length(B0)
        [OptimumTheta(k)]=simContrastvFlip([T1_WM(k) T1_GM(k)],TR(k),0);
    <span class="keyword">end</span>;
    GREs_GM = GRESignal(OptimumTheta,TR,TE,T1_GM,T2s_GM);
    GREs_WM = GRESignal(OptimumTheta,TR,TE,T1_WM,T2s_WM);
    GREs_CSF = GRESignal(OptimumTheta,TR,TE,T1_CSF,T2s_CSF);


    y = SNR_B0 .* 1./sqrt(TR) .*1./sqrt(BW) .*(GREs_WM -GREs_GM);
    <span class="comment">% fitting the model</span>
    beta = PowerLawFit(y,B0);

    powerlawT1(Ns)=beta(2);
    propT1(Ns)=beta(1);

    <span class="keyword">if</span> PlotIntermediate
        figure(fnumbT1)
        subplot(121)
        <span class="keyword">if</span> Ns==1, hold <span class="string">off</span>, <span class="keyword">end</span>;
        plot(B0,y,<span class="string">'Color'</span>,[1 1 1]*(Ns-min(Nslices))/max(Nslices))
        ylabel([<span class="string">'SNR (au)'</span>])
        xlabel([<span class="string">'B_0 (T)'</span>])

        hold <span class="string">on</span>
        subplot(122)
        plot(B0,beta(1)*B0.^(beta(2)),<span class="string">'-.'</span>,<span class="string">'Color'</span>,[1 1 1]*(Ns-min(Nslices))/max(Nslices),<span class="string">'Linewidth'</span>,2)
        ylabel([<span class="string">'fitted SNR (au)'</span>])
        xlabel([<span class="string">'B_0 (T)'</span>])
    <span class="keyword">end</span>;

    y = SNR_B0 .* 1./sqrt(TR) .*1./sqrt(BW) .*abs(GREs_CSF -GREs_GM);
    <span class="comment">% fitting the model</span>
    beta = PowerLawFit(y,B0);

    powerlawT1_GMCSF(Ns)=beta(2);
    propT1_GMCSF(Ns)=beta(1);

    <span class="comment">% SNR in diffusion like experimetns</span>
    <span class="comment">% TE assumed to be constant across fields in the assumption of equally</span>
    <span class="comment">% performing Gradients</span>
    TE = ones(size(B0))*TE_SpinEcho;
    TR = 1.5 * TE * Ns;

    <span class="comment">% calculation of signal</span>
    BW = 1 ./ (TE - DeadTime);

    [OptimumTheta]=ones(size(B0))*90;
    GREs_WM = GRESignal(OptimumTheta,TR,TE,T1_WM,T2s_WM);

    y = SNR_B0 .* 1./sqrt(TR) .*1./sqrt(BW) .*(GREs_WM );
    <span class="comment">% fitting the model</span>
    beta = PowerLawFit(y,B0);

    powerlawDiff(Ns)=beta(2);
    propDiff(Ns)=beta(1);
    <span class="keyword">if</span> PlotIntermediate
        figure(fnumbSE)
        subplot(121)
        <span class="keyword">if</span> Ns==1, hold <span class="string">off</span>, <span class="keyword">end</span>;
        plot(B0,y,<span class="string">'Color'</span>,[1 1 1]*(Ns-min(Nslices))/max(Nslices))
        ylabel([<span class="string">'SNR (au)'</span>])
        xlabel([<span class="string">'B_0 (T)'</span>])
        hold <span class="string">on</span>
        subplot(122)
        plot(B0,beta(1)*B0.^(beta(2)),<span class="string">'-.'</span>,<span class="string">'Color'</span>,[1 1 1]*(Ns-min(Nslices))/max(Nslices),<span class="string">'Linewidth'</span>,2)
        ylabel([<span class="string">'fitted SNR (au)'</span>])
        xlabel([<span class="string">'B_0 (T)'</span>])
    <span class="keyword">end</span>;


<span class="keyword">end</span>;

<span class="keyword">if</span> PlotIntermediate
    figure(fnumbT2)
    title ([<span class="string">'T2*w SNR accounting for TR and BW'</span>])
    figure(fnumbT1)
    title ([<span class="string">'T1 SNR accounting for TR and BW'</span>])
    figure(fnumbSE)
    title ([<span class="string">'SE SNR accounting for TR and BW'</span>])
<span class="keyword">end</span>;

fnumb2D = figure(<span class="string">'name'</span>,<span class="string">'2D Spin Echo '</span>,<span class="string">'numbertitle'</span>,<span class="string">'off'</span>,<span class="string">'Color'</span>,[1 1 1]);
set(fnumb2D,<span class="string">'Position'</span>,[ 461   474   917   369],<span class="string">'Color'</span>,[1 1 1])
subplot(121)
hold <span class="string">off</span>
plot(Nslices,powerlawT2star,<span class="string">'-'</span>,<span class="string">'Color'</span>,[1 1 1]*0.45,<span class="string">'Linewidth'</span>,2);
hold <span class="string">on</span>
plot(Nslices,powerlawT1,<span class="string">'-'</span>,<span class="string">'Color'</span>,[1 1 1]*0.85,<span class="string">'Linewidth'</span>,2);
plot(Nslices,powerlawT1_GMCSF,<span class="string">'-.'</span>,<span class="string">'Color'</span>,[1 1 1]*0.85,<span class="string">'Linewidth'</span>,2);
plot(Nslices,powerlawDiff,<span class="string">'-'</span>,<span class="string">'Color'</span>,[1 1 1]*0.05,<span class="string">'Linewidth'</span>,2);
text(min(Nslices)+(max(Nslices)-min(Nslices))*0.05 ,max(powerlawDiff)*0.5,[<span class="string">'Power Law of SNR = B_0 ^{'</span>,num2str(round(SNR_PowerLaw*10)/10),<span class="string">'}'</span>])

legend(<span class="string">'T_2* weighted GM WM contrast'</span>, <span class="string">'T1 weighted GM WM contrast'</span>,  <span class="string">'T1 weighted GM CSF contrast'</span>, <span class="string">'SNR of T2w'</span>);
ylabel([<span class="string">'Power Law'</span>])
xlabel([<span class="string">'Number of Slices'</span>])
axis <span class="string">tight</span>

subplot(122)
hold <span class="string">off</span>
plot(Nslices,propT2star,<span class="string">'-'</span>,<span class="string">'Color'</span>,[1 1 1]*0.45,<span class="string">'Linewidth'</span>,2);
hold <span class="string">on</span>
plot(Nslices,propT1,<span class="string">'-'</span>,<span class="string">'Color'</span>,[1 1 1]*0.85,<span class="string">'Linewidth'</span>,2);
plot(Nslices,propDiff,<span class="string">'-'</span>,<span class="string">'Color'</span>,[1 1 1]*0.05,<span class="string">'Linewidth'</span>,2);
text(min(Nslices)+(max(Nslices)-min(Nslices))*0.05 ,max(propT2star)*0.8,[<span class="string">'Power Law of SNR = B_0 ^{'</span>,num2str(round(SNR_PowerLaw*10)/10),<span class="string">'}'</span>])

legend(<span class="string">'T_2* weighted GM WM contrast'</span>, <span class="string">'T1 weighted GM WM contrast'</span>, <span class="string">'SNR of T2w'</span>);
ylabel([<span class="string">'Proportionality Constant'</span>])
xlabel([<span class="string">'Number of Slices'</span>])
axis <span class="string">tight</span>

fontScale(1.1)
figure(fnumb2D)

<span class="comment">% savefig('PowerLawsOfContrast');</span>
</pre><img vspace="5" hspace="5" src="SNRandCNRfieldDependenceJMRI_07.png" alt=""> <h2>End of simulations<a name="10"></a></h2><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2015b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Read Me
% cd to the directory where the function SNRandCNRfieldDependenceJMRI.m is located
% you can either run the whole code or simply use the html file to navigate
% through the results


%% initializing path and variables
close all
clear all

CurrDirectory = pwd ;
addpath(genpath(CurrDirectory)) ;

gamma = 42.577e6 ;          % gyromagnetic constant in Hz
SNR_PowerLaw = 1.5 ;        % at High Fields this has been measured at 1.68, at lower fields it is expected to tend towards 1 because noise in the sample
B0 = [0.1:0.1:7] ;          % range of fields of simulations

%(time needed to crush magnetization, apply slice selective and phase encoding gradients)
DeadTime = 3e-3 ;           % assumption of dead time within a GRE

PDT1approach = 'ShortEnoughTE' ; % options are 'ShortEnoughTE' or 'minTR'
minTR = 7e-3 ;              % minimum repetition time achievable (used in PD and T1w in case of minTR)
TEfractionOfT2 = 1 / 8 ;    % fraction of shorter T2 at which we assume that no T2* contrast exists (used for PD and T1w)

PDflip_Ernstfract = 0.25 ;  % fraction of the Ernst flip angle used for PD

TE_SpinEcho = 70e-3;        % used on the 2D example

PlotIntermediate = 0 ;

%% initializing relaxation times field dependence
% Longitudinal and transverse relaxation rates using the models presented
% in:
% - Rooney et al MRM 2007;
% - Pohmann et al MRM 2016;


% R1 as a function of magnetic field according to
% Rooney et al, MRM, 2007
% and using a model suggested by Bottemley et al, Med Phys, 1984
T1_WM = 0.00071 * (gamma*B0).^0.382;
T1_GM = 0.00116 * (gamma*B0).^0.376;
T1_BL = 0.00335 * (gamma*B0).^0.340;
T1_CSF =1/0.231 * ones(size(B0));

% using Pohmann et al, MRM, 2016
T2s_GM = 0.090 * exp(-0.142 *B0);
T2s_WM = 0.064 * exp(-0.132 *B0);
T2s_CSF = 0.1*ones(size(B0)); % made up.. but not too relevant
SNR_B0 = B0.^SNR_PowerLaw ;


%% relaxation parameters - plotting relaxation parameters as a function of field
figure('name','Relaxation Rates ','numbertitle','off')
set(gcf,'Position',[ 11   627   917   369],'Color',[1 1 1])
subplot(121)
hold off
plot(B0,1./T1_GM,'-','Color',[1 1 1]*0.0,'Linewidth',2)
hold on
plot(B0,1./T1_WM,'-','Color',[1 1 1]*0.35,'Linewidth',2)
plot(B0,1./T1_CSF,'-.','Color',[1 1 1]*0.8,'Linewidth',2)
legend('GM ','WM ', 'CSF');
title (['R_1 as a function of B_0'])
ylabel(['R_1 (s^{-1})'])
xlabel(['B_0 (T)'])
axis tight

subplot(122)
hold off
plot(B0,1./T2s_GM,'-','Color',[1 1 1]*0.0,'Linewidth',2)
hold on
plot(B0,1./T2s_WM,'-','Color',[1 1 1]*0.35,'Linewidth',2)
legend('GM ','WM ')
title (['R_2^* as a function of B_0'])
ylabel(['R_2^* (s^{-1})'])
xlabel(['B_0 (T)'])
axis tight
fontScale(1.1)


figure('name','Relaxation times ','numbertitle','off')
set(gcf,'Position',[ 11   627   917   369],'Color',[1 1 1])
subplot(121)
hold off
plot(B0,T1_GM,'-','Color',[1 1 1]*0.0,'Linewidth',2)
hold on
plot(B0,T1_WM,'-','Color',[1 1 1]*0.4,'Linewidth',2)
plot(B0,T1_CSF,'-.','Color',[1 1 1]*0.8,'Linewidth',2)
legend('GM ','WM ', 'CSF','Location','East');
axis tight
axis([0 max(B0) 0 max(T1_CSF)*1.1])
title (['T_1 as a function of B0'])
ylabel(['T_1 (s)'])
xlabel(['B_0 (T)'])

subplot(122)
hold off
plot(B0,T2s_GM,'-','Color',[1 1 1]*0.0,'Linewidth',2)
hold on
plot(B0,T2s_WM,'-','Color',[1 1 1]*0.4,'Linewidth',2)
axis tight
axis([0 max(B0) 0 max(T2s_GM)*1.1])

legend('GM ','WM ')
title (['T_2^* as a function of B0'])
ylabel(['T_2^* (s)'])
xlabel(['B_0 (T)'])
fontScale(1.1)
% savefig('RelaxationTimes')

%% Functions 
% Ernst Angle and GRE signal calculation

% Ernst Angle Calculation in degrees
Ernstangle_d = @(TRep,T1) acosd( exp(-TRep./T1) );

% GRESignal calculation
GRESignal = @(FlipAngle,TRep,TE,T1,T2) sind(FlipAngle).*exp(-TE/T2).*(1-exp(-TRep./T1))./(1-(exp(-TRep./T1)).*cosd(FlipAngle));


%% T1-w imaging
% Sequence optimized (flip angle and TR, while TE= T2s_WM * TEfractionOfT2) 
% at each B0 to yield maximum contrast between grey and white matter

if strcmp(PDT1approach,'minTR')
    % At Fixed TR
    TR = minTR * ones(size(B0));
    TE = TR / 2;
elseif strcmp(PDT1approach,'ShortEnoughTE')
    % Using a "short" TE in respect to T2 of WM
    TE = T2s_WM * TEfractionOfT2;
    TR = 2 * TE;
else
    error('Unknow PD and T1 approach, it has to be either ''ShortEnoughTE'' or ''minTR'' ')
end;

% calculation of signal
BW = 1 ./ (2 * TE - DeadTime);

OptimumTheta=zeros([1,length(B0)]);
for k=1:length(B0)
    [OptimumTheta(k)]=simContrastvFlip([T1_WM(k) T1_GM(k)],TR(k),0);
end;
GREs_GM = GRESignal(OptimumTheta,TR,TE,T1_GM,T2s_GM);
GREs_WM = GRESignal(OptimumTheta,TR,TE,T1_WM,T2s_WM);
GREs_CSF = GRESignal(OptimumTheta,TR,TE,T1_CSF,T2s_CSF);

figure('name','T1w imaging ','numbertitle','off')
set(gcf,'Position',[ 936   165   917   369],'Color',[1 1 1])
subplot(121)
hold off
plot(B0,GREs_GM,'-','Color',[1 1 1]*0.0,'Linewidth',2)
hold on
plot(B0,GREs_WM,'-','Color',[1 1 1]*0.35,'Linewidth',2)
plot(B0,GREs_CSF,'-.','Color',[1 1 1]*0.8,'Linewidth',2)
plot(B0,GREs_WM-GREs_GM,'-','Color',[1 1 1]*0.6,'Linewidth',2)
legend('GM ','WM ','CSF','GM vs WM contrast')
% legend('GM ','WM ','GM vs WM contrast')
title (['T_1w Signal as a function of B_0'])
ylabel(['Signal '])
xlabel(['B_0 (T)'])
axis tight

subplot(122)
hold off

plot(B0,SNR_B0 .* 1./sqrt(TR) .*1./sqrt(BW) .*GREs_GM,'-','Color',[1 1 1]*0.0,'Linewidth',2)
hold on
plot(B0,SNR_B0 .* 1./sqrt(TR) .*1./sqrt(BW) .*GREs_WM,'-','Color',[1 1 1]*0.35,'Linewidth',2)
plot(B0,SNR_B0 .* 1./sqrt(TR) .*1./sqrt(BW) .*GREs_CSF,'-','Color',[1 1 1]*0.8,'Linewidth',2)
plot(B0,SNR_B0 .* 1./sqrt(TR) .*1./sqrt(BW) .*(GREs_WM-GREs_GM),'-','Color',[1 1 1]*0.6,'Linewidth',2)
% legend('GM ','WM ','GM vs WM contrast')
title (['T_1w SNR accounting for TR and BW'])
ylabel(['SNR (au)'])
xlabel(['B_0 (T)'])
axis tight
y1 = SNR_B0 .* 1./sqrt(TR) .*1./sqrt(BW) .*(GREs_WM );
y = SNR_B0 .* 1./sqrt(TR) .*1./sqrt(BW) .*(GREs_WM -GREs_GM);


% fitting the model using a log transform re-weighted by the amplitude for
% a more balanced weigthting
beta = PowerLawFit(y,B0);

plot(B0,beta(1)*B0.^(beta(2)),'-.','Color',[1 1 1]*0.6,'Linewidth',2)
legend('GM ','WM ','CSF','GM vs WM contrast','GM vs WM contrast fit','Location','East')


text(min(B0)+(max(B0)-min(B0))*0.05 ,max(y1)*0.9,['Power Law of T_1w CNR = B_0 ^{',num2str(round(beta(2)*100)/100),'}'])
text(min(B0)+(max(B0)-min(B0))*0.05 ,max(y1)*0.8,['Power Law of SNR = B_0 ^{',num2str(round(SNR_PowerLaw*10)/10),'}'])
fontScale(1.1)


%  savefig('T1wCNR_VariableTR')
figure('name','T1w Ernst Angle ','numbertitle','off')
set(gcf,'Position',[ 1367  599  426 344],'Color',[1 1 1])
hold off
plot(B0,TR*1000,'-','Color',[1 1 1]*0.0,'Linewidth',2)
hold on
plot(B0,OptimumTheta,'-','Color',[1 1 1]*0.5,'Linewidth',2)
legend('TR (ms)','Flip Angle (degrees)')
legend('TR (ms)','Flip Angle (degrees)','Location','Best')
xlabel(['B_0 (T)'])
ylabel(['Flip Angle (degrees) ; TR (ms)'])
title(['sequence Paraemters as a function of B_0'])
fontScale(1.1)

% savefig('T1w_VariableTR_parameters')

%% PD-w imaging
% Sequence optimized (flip angle = PDflip_Ernstfract  * ErnstAngle , while TE= T2s_WM * TEfractionOfT2) 
% at each B0 to yield a proton density type of contrast

if strcmp(PDT1approach,'minTR')
    %At Fixed TR
    TR = minTR * ones(size(B0));
    TE = TR / 2;
elseif strcmp(PDT1approach,'ShortEnoughTE')
    TE = T2s_WM * TEfractionOfT2;
    TR = 2 * TE;
else
    error('Unknow PD and T1 approach, it has to be either ''ShortEnoughTE'' or ''minTR'' ')
end;

%calculation of signal
BW = 1 ./ (2 * TE - DeadTime);
theta = PDflip_Ernstfract  * Ernstangle_d(TR,T1_GM);
GREs_GM = GRESignal(theta,TR,TE,T1_GM,T2s_GM);
GREs_WM = GRESignal(theta,TR,TE,T1_WM,T2s_WM);
GREs_CSF = GRESignal(theta,TR,TE,T1_CSF,T2s_CSF);

figure('name','PD imaging ','numbertitle','off')

set(gcf,'Position',[ 938   627   917   369],'Color',[1 1 1])
subplot(121)
hold off
plot(B0,GREs_GM,'-','Color',[1 1 1]*0.0,'Linewidth',2)
hold on
plot(B0,GREs_WM,'-','Color',[1 1 1]*0.35,'Linewidth',2)
plot(B0,GREs_CSF,'-','Color',[1 1 1]*0.8,'Linewidth',2)
legend('GM ','WM ','CSF')
legend('GM ','WM ')
title (['PD Signal as a function of B0'])
ylabel(['Signal '])
xlabel(['B_0 (T)'])
axis tight

subplot(122)
hold off

plot(B0,SNR_B0 .* 1./sqrt(TR) .*1./sqrt(BW) .*GREs_GM,'-','Color',[1 1 1]*0.0,'Linewidth',2)
hold on
plot(B0,SNR_B0 .* 1./sqrt(TR) .*1./sqrt(BW) .*GREs_WM,'-','Color',[1 1 1]*0.35,'Linewidth',2)
plot(B0,SNR_B0 .* 1./sqrt(TR) .*1./sqrt(BW) .*GREs_CSF,'-','Color',[1 1 1]*0.8,'Linewidth',2)
title (['PD SNR accounting for TR and BW'])
ylabel(['SNR (au)'])
xlabel(['B_0 (T)'])
axis tight
y = SNR_B0 .* 1./sqrt(TR) .*1./sqrt(BW) .*GREs_WM;

% fitting the model 
beta = PowerLawFit(y,B0);

plot(B0,beta(1)*B0.^(beta(2)),'-.','Color',[1 1 1]*0.6,'Linewidth',2)
text(min(B0)+(max(B0)-min(B0))*0.05 ,max(y)*0.9,['Power Law of PD SNR = B_0 ^{',num2str(round(beta(2)*100)/100),'}'])

text(min(B0)+(max(B0)-min(B0))*0.05 ,max(y)*0.8,['Power Law of SNR = B_0 ^{',num2str(round(SNR_PowerLaw*10)/10),'}'])
legend('GM ','WM ','CSF ','GM fit','Location','East')
fontScale(1.1)
% savefig('PDCNR_VariableTR')

%% T2*-w imaging contrast
% Sequence optimized to have the TE that gives the optimum GM WM contrast at given field
% Remainging parameters were optimizer for SNR

for k=1:length(B0)
    [TE(k)]=simContrastvTE([T2s_WM(k) T2s_GM(k)]*1000,0)/1000;
end;
TR = 2 * TE;
OptimumTheta = Ernstangle_d(TR,T1_GM);
%calculation of signal
BW = 1 ./ (2 * TE - DeadTime);
GREs_GM = GRESignal(OptimumTheta,TR,TE,T1_GM,T2s_GM);
GREs_WM = GRESignal(OptimumTheta,TR,TE,T1_WM,T2s_WM);


figure('name','T2*w ','numbertitle','off')
set(gcf,'Position',[8   167   917   369],'Color',[1 1 1])
subplot(121)
hold off
plot(B0,GREs_GM,'-','Color',[1 1 1]*0.0,'Linewidth',2)
hold on
plot(B0,GREs_WM,'-','Color',[1 1 1]*0.35,'Linewidth',2)
plot(B0,GREs_WM-GREs_GM,'-','Color',[1 1 1]*0.6,'Linewidth',2)
legend('GM ','WM ','GM vs WM contrast')
title (['T_2*w Signal as a function of B_0'])
ylabel(['Signal '])
xlabel(['B_0 (T)'])
axis tight

subplot(122)
hold off

plot(B0,SNR_B0 .* 1./sqrt(TR) .*1./sqrt(BW) .*GREs_GM,'-','Color',[1 1 1]*0.0,'Linewidth',2)
hold on
plot(B0,SNR_B0 .* 1./sqrt(TR) .*1./sqrt(BW) .*GREs_WM,'-','Color',[1 1 1]*0.35,'Linewidth',2)
plot(B0,SNR_B0 .* 1./sqrt(TR) .*1./sqrt(BW) .*(GREs_GM-GREs_WM),'-','Color',[1 1 1]*0.6,'Linewidth',2)
%
title (['T2*w SNR accounting for TR and BW'])
ylabel(['SNR (au)'])
xlabel(['B_0 (T)'])
axis tight
y1 = SNR_B0 .* 1./sqrt(TR) .*1./sqrt(BW) .*(GREs_GM );
y = SNR_B0 .* 1./sqrt(TR) .*1./sqrt(BW) .*(GREs_GM -GREs_WM);
x0=[0.1 1];

% fitting the model 
beta = PowerLawFit(y,B0);

plot(B0,beta(1)*B0.^(beta(2)),'-.','Color',[1 1 1]*0.6,'Linewidth',2)
legend('GM ','WM ','GM vs WM contrast','GM vs WM contrast fit','Location','East')

text(min(B0)+(max(B0)-min(B0))*0.05 ,max(y1)*0.9,['Power Law of T2*w CNR = B_0 ^{',num2str(round(beta(2)*100)/100),'}'])
text(min(B0)+(max(B0)-min(B0))*0.05 ,max(y1)*0.8,['Power Law of SNR = B_0 ^{',num2str(round(SNR_PowerLaw*10)/10),'}'])
fontScale(1.1)

% savefig('T2swCNR_VariableTR ')

%%


%% 2D GRE signal considering the number of interleaved slices per TR
% T1 and T2*-w were obtained using the same consideration as in the previous sections;
% T2w in diffusion like experiments was also simulated:
%       TE assumed to be constant across fields 

Nslices =1:64;
if PlotIntermediate
    
    fnumbT2 = figure('name','2D T2* Ernst Angle ','numbertitle','off','Color',[1 1 1])
    
    fnumbT1 = figure('name','2D T1w  ','numbertitle','off','Color',[1 1 1])
    
    fnumbSE = figure('name','2D Spin Echo ','numbertitle','off','Color',[1 1 1])
end;
for Ns=Nslices;
    % T2* contrast
    
    for k=1:length(B0)
        [TE(k)]=simContrastvTE([T2s_WM(k) T2s_GM(k)]*1000,0)/1000;
    end;
    %calculation of signal
    BW = 1 ./ (2 * TE - DeadTime);
    TR = 2 * TE * Ns;
    OptimumTheta = Ernstangle_d(TR,T1_GM);
    
    GREs_GM = GRESignal(OptimumTheta,TR,TE,T1_GM,T2s_GM);
    GREs_WM = GRESignal(OptimumTheta,TR,TE,T1_WM,T2s_WM);
    
    y1 = SNR_B0 .* 1./sqrt(TR) .*1./sqrt(BW) .*(GREs_GM );
    y = SNR_B0 .* 1./sqrt(TR) .*1./sqrt(BW) .*(GREs_GM -GREs_WM);
    % fitting the model 
    beta = PowerLawFit(y,B0);
    % plot(B0,beta(1)*B0.^(beta(2)),'-.','Color',[1 1 1]*0.6,'Linewidth',2)
    powerlawT2star(Ns)=beta(2);
    propT2star(Ns)=beta(1);
    
    
    if PlotIntermediate
        figure(fnumbT2)
        if Ns==1, hold off, end;
        subplot(121)
        plot(B0,y,'Color',[1 1 1]*(Ns-min(Nslices))/max(Nslices))
        ylabel([' SNR (au)'])
        xlabel(['B_0 (T)'])
        hold on
        subplot(122)
        plot(B0,beta(1)*B0.^(beta(2)),'-.','Color',[1 1 1]*(Ns-min(Nslices))/max(Nslices),'Linewidth',2)
        hold on
        ylabel(['fitted SNR (au)'])
        xlabel(['B_0 (T)'])
    end;
    
    % T1 contrast
    TE = T2s_WM * TEfractionOfT2;
    TR = 2 * TE * Ns;
    
    %calculation of signal
    BW = 1 ./ (2 * TE - DeadTime);
    
    
    for k=1:length(B0)
        [OptimumTheta(k)]=simContrastvFlip([T1_WM(k) T1_GM(k)],TR(k),0);
    end;
    GREs_GM = GRESignal(OptimumTheta,TR,TE,T1_GM,T2s_GM);
    GREs_WM = GRESignal(OptimumTheta,TR,TE,T1_WM,T2s_WM);
    GREs_CSF = GRESignal(OptimumTheta,TR,TE,T1_CSF,T2s_CSF);
    
    
    y = SNR_B0 .* 1./sqrt(TR) .*1./sqrt(BW) .*(GREs_WM -GREs_GM);
    % fitting the model 
    beta = PowerLawFit(y,B0);
    
    powerlawT1(Ns)=beta(2);
    propT1(Ns)=beta(1);
    
    if PlotIntermediate
        figure(fnumbT1)
        subplot(121)
        if Ns==1, hold off, end;
        plot(B0,y,'Color',[1 1 1]*(Ns-min(Nslices))/max(Nslices))
        ylabel(['SNR (au)'])
        xlabel(['B_0 (T)'])
        
        hold on
        subplot(122)
        plot(B0,beta(1)*B0.^(beta(2)),'-.','Color',[1 1 1]*(Ns-min(Nslices))/max(Nslices),'Linewidth',2)
        ylabel(['fitted SNR (au)'])
        xlabel(['B_0 (T)'])
    end;
    
    y = SNR_B0 .* 1./sqrt(TR) .*1./sqrt(BW) .*abs(GREs_CSF -GREs_GM);
    % fitting the model 
    beta = PowerLawFit(y,B0);
    
    powerlawT1_GMCSF(Ns)=beta(2);
    propT1_GMCSF(Ns)=beta(1);
    
    % SNR in diffusion like experimetns
    % TE assumed to be constant across fields in the assumption of equally
    % performing Gradients
    TE = ones(size(B0))*TE_SpinEcho;
    TR = 1.5 * TE * Ns;
    
    % calculation of signal
    BW = 1 ./ (TE - DeadTime);
    
    [OptimumTheta]=ones(size(B0))*90;
    GREs_WM = GRESignal(OptimumTheta,TR,TE,T1_WM,T2s_WM);
    
    y = SNR_B0 .* 1./sqrt(TR) .*1./sqrt(BW) .*(GREs_WM );
    % fitting the model
    beta = PowerLawFit(y,B0);
    
    powerlawDiff(Ns)=beta(2);
    propDiff(Ns)=beta(1);
    if PlotIntermediate
        figure(fnumbSE)
        subplot(121)
        if Ns==1, hold off, end;
        plot(B0,y,'Color',[1 1 1]*(Ns-min(Nslices))/max(Nslices))
        ylabel(['SNR (au)'])
        xlabel(['B_0 (T)'])
        hold on
        subplot(122)
        plot(B0,beta(1)*B0.^(beta(2)),'-.','Color',[1 1 1]*(Ns-min(Nslices))/max(Nslices),'Linewidth',2)
        ylabel(['fitted SNR (au)'])
        xlabel(['B_0 (T)'])
    end;
    
    
end;

if PlotIntermediate    
    figure(fnumbT2)
    title (['T2*w SNR accounting for TR and BW'])
    figure(fnumbT1)
    title (['T1 SNR accounting for TR and BW'])
    figure(fnumbSE)
    title (['SE SNR accounting for TR and BW'])   
end;

fnumb2D = figure('name','2D Spin Echo ','numbertitle','off','Color',[1 1 1]);
set(fnumb2D,'Position',[ 461   474   917   369],'Color',[1 1 1])
subplot(121)
hold off
plot(Nslices,powerlawT2star,'-','Color',[1 1 1]*0.45,'Linewidth',2);
hold on
plot(Nslices,powerlawT1,'-','Color',[1 1 1]*0.85,'Linewidth',2);
plot(Nslices,powerlawT1_GMCSF,'-.','Color',[1 1 1]*0.85,'Linewidth',2);
plot(Nslices,powerlawDiff,'-','Color',[1 1 1]*0.05,'Linewidth',2);
text(min(Nslices)+(max(Nslices)-min(Nslices))*0.05 ,max(powerlawDiff)*0.5,['Power Law of SNR = B_0 ^{',num2str(round(SNR_PowerLaw*10)/10),'}'])

legend('T_2* weighted GM WM contrast', 'T1 weighted GM WM contrast',  'T1 weighted GM CSF contrast', 'SNR of T2w');
ylabel(['Power Law'])
xlabel(['Number of Slices'])
axis tight

subplot(122)
hold off
plot(Nslices,propT2star,'-','Color',[1 1 1]*0.45,'Linewidth',2);
hold on
plot(Nslices,propT1,'-','Color',[1 1 1]*0.85,'Linewidth',2);
plot(Nslices,propDiff,'-','Color',[1 1 1]*0.05,'Linewidth',2);
text(min(Nslices)+(max(Nslices)-min(Nslices))*0.05 ,max(propT2star)*0.8,['Power Law of SNR = B_0 ^{',num2str(round(SNR_PowerLaw*10)/10),'}'])

legend('T_2* weighted GM WM contrast', 'T1 weighted GM WM contrast', 'SNR of T2w');
ylabel(['Proportionality Constant'])
xlabel(['Number of Slices'])
axis tight

fontScale(1.1)
figure(fnumb2D)

% savefig('PowerLawsOfContrast');


%% End of simulations
##### SOURCE END #####
--></body></html>